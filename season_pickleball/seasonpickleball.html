<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Pickleball Season - Court Management</title>
        <link rel="stylesheet" href="../styles.css">
        <style>
            .round-controls {
                text-align: center;
                margin: 20px 0;
                padding: 15px;
                background-color: #e9ecef;
                border-radius: 8px;
            }
            .round-controls button {
                margin: 5px;
            }
            .session-header {
                background-color: #2c5aa0;
                color: white;
                padding: 10px;
                border-radius: 5px;
                margin-bottom: 15px;
                font-weight: bold;
                cursor: pointer;
                user-select: none;
                display: flex;
                justify-content: space-between;
                align-items: center;
                transition: background-color 0.2s;
            }
            .session-header:hover {
                background-color: #1e3f73;
            }
            .session-header .toggle-icon {
                font-size: 1.2em;
                transition: transform 0.3s;
            }
            .session-header.collapsed .toggle-icon {
                transform: rotate(-90deg);
            }
            .session-header .header-content {
                display: flex;
                align-items: center;
                gap: 10px;
                flex: 1;
            }
            .session-header .export-btn,
            .session-header .print-btn {
                background-color: rgba(255, 255, 255, 0.2);
                border: 1px solid rgba(255, 255, 255, 0.3);
                color: white;
                padding: 5px 10px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.85em;
                transition: background-color 0.2s;
                margin-right: 5px;
            }
            .session-header .export-btn:hover,
            .session-header .print-btn:hover {
                background-color: rgba(255, 255, 255, 0.3);
            }
            .session-header .export-btn:active,
            .session-header .print-btn:active {
                background-color: rgba(255, 255, 255, 0.4);
            }
            .session-matches {
                transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin-bottom 0.3s ease-out;
                overflow: hidden;
                max-height: 5000px; /* Large enough to accommodate content */
            }
            .session-matches.collapsed {
                max-height: 0;
                opacity: 0;
                margin-bottom: 0;
            }
            .subs-section {
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 5px;
                padding: 15px;
                margin-bottom: 15px;
            }
            .subs-section h4 {
                margin-top: 0;
                margin-bottom: 10px;
                color: #2c5aa0;
                font-size: 1em;
            }
            .add-sub-form {
                display: flex;
                gap: 10px;
                align-items: flex-end;
                margin-bottom: 15px;
                flex-wrap: wrap;
            }
            .add-sub-form input,
            .add-sub-form select {
                padding: 8px;
                border: 1px solid #ced4da;
                border-radius: 4px;
                font-size: 0.9em;
            }
            .add-sub-form input[type="text"] {
                flex: 1;
                min-width: 150px;
            }
            .add-sub-form select {
                flex: 1;
                min-width: 200px;
            }
            .add-sub-form button {
                padding: 8px 15px;
                background-color: #28a745;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.9em;
            }
            .add-sub-form button:hover {
                background-color: #218838;
            }
            .subs-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }
            .sub-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px;
                background-color: white;
                border: 1px solid #dee2e6;
                border-radius: 4px;
            }
            .sub-item-info {
                flex: 1;
            }
            .sub-item-name {
                font-weight: bold;
                color: #2c5aa0;
            }
            .sub-item-for {
                font-size: 0.9em;
                color: #6c757d;
                margin-left: 10px;
            }
            .sub-item button {
                background-color: #dc3545;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 5px 10px;
                cursor: pointer;
                font-size: 0.85em;
            }
            .sub-item button:hover {
                background-color: #c82333;
            }
            .previous-points {
                font-size: 0.85em;
                color: #666;
                font-style: italic;
                margin-left: 5px;
            }
            .btn-save:hover {
                background-color: #5a32a3 !important;
            }
            .btn-load:hover {
                background-color: #1aa179 !important;
            }
            #loadSeasonDialog {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.5);
                z-index: 2000;
                justify-content: center;
                align-items: center;
            }
            .page-header {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 20px;
                margin-bottom: 20px;
            }
            .page-logo {
                height: 80px;
                width: auto;
                max-width: 200px;
            }
            .page-header h1 {
                margin: 0;
            }
            @media (max-width: 600px) {
                .page-header {
                    flex-direction: column;
                    gap: 10px;
                }
                .page-logo {
                    height: 60px;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="page-header">
                <img src="dink-shots.webp" alt="Dink Shots Logo" class="page-logo" />
                <h1>üèì Pickleball Season - Court Management</h1>
            </div>

            <!-- Control Buttons -->
            <div class="controls">
                <button class="btn btn-export" onclick="exportData()">üì§ Export Season Data</button>
                <button class="btn btn-import" onclick="document.getElementById('fileInput').click()">üì• Import Season Data</button>
                <button class="btn btn-save" onclick="saveToLocalStorage()" style="background-color: #6f42c1; color: white;">üíæ Save Season Data</button>
                <button class="btn btn-load" onclick="showLoadSeasonDialog()" style="background-color: #20c997; color: white;">üìÇ Load Saved Season</button>
                <button class="btn btn-print" onclick="printSeasonSummary()">üñ®Ô∏è Print Season Summary</button>
                <button class="btn btn-clear" onclick="clearAllData()">üóëÔ∏è Clear All Data</button>
                <input type="file" id="fileInput" class="file-input" accept=".json" onchange="importData(event)" />
            </div>

            <!-- Load Season Dialog -->
            <div id="loadSeasonDialog">
                <div style="background-color: white; padding: 30px; border-radius: 10px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                    <h3 style="margin-top: 0; color: #2c5aa0;">Load Saved Season</h3>
                    <div id="savedSeasonsList" style="margin: 20px 0;">
                        <!-- Saved seasons will be listed here -->
                    </div>
                    <div style="text-align: right;">
                        <button class="btn" onclick="hideLoadSeasonDialog()" style="background-color: #6c757d; color: white;">Cancel</button>
                    </div>
                </div>
            </div>

            <!-- Court Selection Section -->
            <div class="player-count-section">
                <h3>Season Setup</h3>
                <div class="player-count-input">
                    <label>Number of Courts:</label>
                    <input type="number" id="numCourts" min="1" max="10" value="2" onchange="updatePlayerCount()" />
                    <span id="playerCountDisplay">8 players</span>
                </div>
                <div class="info-text">
                    <button class="btn btn-tournament" onclick="initializeSeason()" style="margin-top: 10px;">Initialize Season</button>
                </div>
            </div>

            <!-- Player Names Section -->
            <div class="player-section" id="playerSection" style="display: none;">
                <h3>Player Names</h3>
                <div class="player-grid" id="playerGrid">
                    <!-- Player inputs will be generated dynamically -->
                </div>
            </div>

            <!-- Match Controls -->
            <div class="round-controls" id="matchControls" style="display: none;">
                <button class="btn btn-generate" onclick="generateNextMatch()">üé≤ Generate Next Match</button>
                <button class="btn btn-generate" onclick="generateNewCourts()" style="background-color: #17a2b8;">üîÑ End Session and Generate New Courts</button>
                <span id="matchStatus"></span>
            </div>

            <!-- Tournament Sessions -->
            <div id="tournamentSessions">
                <!-- Sessions will be generated dynamically -->
            </div>

            <!-- Summary Section -->
            <div class="summary-section">
                <h3>üèÜ Season Standings</h3>
                <div class="summary-grid" id="summaryGrid">
                    <!-- Summary items will be generated dynamically -->
                </div>
            </div>
        </div>

        <!-- Toast notification -->
        <div id="toast" class="toast"></div>

        <script>
            let numCourts = 0;
            let currentPlayerCount = 0;
            let players = []; // Array of player objects: {id, name}
            let sessions = []; // Array of sessions: [{sessionId, courtAssignments: [[players]], matches: [{court, team1, team2, team1Score, team2Score}]}]
            let currentSessionId = 0;
            let currentSessionTeammateCounts = {}; // Track teammate pairings per session: {sessionId: {court: {playerId: {teammateId: count}}}}
            let sessionCollapsedState = {}; // Track collapsed state for each session: {sessionId: boolean}
            let sessionSubs = {}; // Track subs per session: {sessionId: [{subName: string, subbingFor: playerId, court: number}]}

            // Update player count display
            function updatePlayerCount() {
                const courts = parseInt(document.getElementById('numCourts').value) || 1;
                const totalPlayers = courts * 4;
                document.getElementById('playerCountDisplay').textContent = `${totalPlayers} players`;
            }

            // Initialize season
            function initializeSeason() {
                numCourts = parseInt(document.getElementById('numCourts').value) || 1;
                currentPlayerCount = numCourts * 4;
                
                if (numCourts < 1) {
                    showToast('Please select at least 1 court', true);
                    return;
                }

                // Reset data
                players = [];
                sessions = [];
                currentSessionId = 0;
                currentSessionTeammateCounts = {};
                sessionCollapsedState = {};
                sessionSubs = {};

                // Initialize players
                for (let i = 0; i < currentPlayerCount; i++) {
                    players.push({
                        id: i,
                        name: `Player ${i + 1}`
                    });
                }

                // Show player section
                document.getElementById('playerSection').style.display = 'block';
                document.getElementById('matchControls').style.display = 'block';

                generatePlayerInputs();
                generateSummarySection();
                
                // Generate first match
                generateFirstMatch();

                showToast(`Season initialized with ${numCourts} court(s) and ${currentPlayerCount} players!`);
            }

            // Generate player input fields
            function generatePlayerInputs() {
                const playerGrid = document.getElementById('playerGrid');
                playerGrid.innerHTML = '';

                players.forEach((player, index) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-input';
                    playerDiv.innerHTML = `
                        <label>Player ${index + 1}</label>
                        <input type="text" id="player${index}" placeholder="Enter name" value="${player.name}" />
                    `;
                    playerGrid.appendChild(playerDiv);
                });

                // Add event listeners
                players.forEach((player, index) => {
                    const input = document.getElementById(`player${index}`);
                    if (input) {
                        input.addEventListener('input', (e) => {
                            players[index].name = e.target.value || `Player ${index + 1}`;
                            updatePlayerDisplays();
                            updateStats();
                        });
                    }
                });
            }

            // Helper function to get current date in readable format
            function getCurrentDate() {
                const now = new Date();
                return now.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
            }

            // Generate first match - ordered by player array, pairing (0&3) vs (1&2)
            function generateFirstMatch() {
                // Create first session
                const sessionId = currentSessionId++;
                const courtAssignments = [];
                const matches = [];

                // Assign players to courts (0-3 on court 1, 4-7 on court 2, etc.)
                for (let court = 0; court < numCourts; court++) {
                    const courtPlayers = [];
                    for (let i = 0; i < 4; i++) {
                        const playerIndex = court * 4 + i;
                        courtPlayers.push(playerIndex);
                    }
                    courtAssignments.push(courtPlayers);

                    // Create match: (0&3) vs (1&2) pattern
                    const team1 = [courtPlayers[0], courtPlayers[3]];
                    const team2 = [courtPlayers[1], courtPlayers[2]];
                    matches.push({
                        court: court,
                        team1: team1,
                        team2: team2,
                        team1Score: '',
                        team2Score: ''
                    });
                }

                sessions.push({
                    sessionId: sessionId,
                    date: getCurrentDate(),
                    courtAssignments: courtAssignments,
                    matches: matches
                });

                // Initialize teammate tracking for this session
                initializeSessionTeammateTracking(sessionId, courtAssignments);

                renderAllSessions();
                updateMatchStatus();
                updateStats();
            }

            // Initialize teammate tracking for a session
            function initializeSessionTeammateTracking(sessionId, courtAssignments) {
                if (!currentSessionTeammateCounts[sessionId]) {
                    currentSessionTeammateCounts[sessionId] = {};
                }

                courtAssignments.forEach((courtPlayers, court) => {
                    if (!currentSessionTeammateCounts[sessionId][court]) {
                        currentSessionTeammateCounts[sessionId][court] = {};
                    }

                    courtPlayers.forEach(playerId => {
                        if (!currentSessionTeammateCounts[sessionId][court][playerId]) {
                            currentSessionTeammateCounts[sessionId][court][playerId] = {};
                        }
                        courtPlayers.forEach(teammateId => {
                            if (playerId !== teammateId) {
                                currentSessionTeammateCounts[sessionId][court][playerId][teammateId] = 0;
                            }
                        });
                    });
                });
            }

            // Record teammate pairing in current session
            function recordTeammatePairing(sessionId, court, team) {
                const [p1, p2] = team;
                if (currentSessionTeammateCounts[sessionId] && 
                    currentSessionTeammateCounts[sessionId][court] &&
                    currentSessionTeammateCounts[sessionId][court][p1]) {
                    currentSessionTeammateCounts[sessionId][court][p1][p2] = 
                        (currentSessionTeammateCounts[sessionId][court][p1][p2] || 0) + 1;
                }
                if (currentSessionTeammateCounts[sessionId] && 
                    currentSessionTeammateCounts[sessionId][court] &&
                    currentSessionTeammateCounts[sessionId][court][p2]) {
                    currentSessionTeammateCounts[sessionId][court][p2][p1] = 
                        (currentSessionTeammateCounts[sessionId][court][p2][p1] || 0) + 1;
                }
            }

            // Generate next match - keep same courts, switch teammates
            function generateNextMatch() {
                if (sessions.length === 0) {
                    showToast('Please initialize season first', true);
                    return;
                }

                const currentSession = sessions[sessions.length - 1];
                const sessionId = currentSession.sessionId;
                const courtAssignments = currentSession.courtAssignments;
                const existingMatches = currentSession.matches;

                // Generate next valid matchups for each court
                const newMatches = [];

                for (let court = 0; court < numCourts; court++) {
                    const courtPlayers = courtAssignments[court];
                    const nextMatchup = findNextValidMatchup(courtPlayers, sessionId, court, existingMatches);

                    if (!nextMatchup) {
                        showToast(`Court ${court + 1}: All possible matchups have been played twice. Consider generating new courts.`, true);
                        // Use fallback pairing
                        const fallback = generateFallbackMatchup(courtPlayers);
                        newMatches.push({
                            court: court,
                            team1: fallback.team1,
                            team2: fallback.team2,
                            team1Score: '',
                            team2Score: ''
                        });
                    } else {
                        newMatches.push({
                            court: court,
                            team1: nextMatchup.team1,
                            team2: nextMatchup.team2,
                            team1Score: '',
                            team2Score: ''
                        });
                    }
                }

                // Add matches to current session
                currentSession.matches.push(...newMatches);

                // Record teammate pairings
                newMatches.forEach(match => {
                    recordTeammatePairing(sessionId, match.court, match.team1);
                    recordTeammatePairing(sessionId, match.court, match.team2);
                });

                renderAllSessions();
                updateMatchStatus();
                updateStats();

                showToast('Next match generated!');
            }

            // Find next valid matchup for a court using the new pattern algorithm
            function findNextValidMatchup(courtPlayers, sessionId, court, existingMatches) {
                // Count how many matches have been played on this court in this session
                const courtMatchCount = existingMatches.filter(m => m.court === court).length;
                const gameNumber = courtMatchCount + 1; // 1-indexed game number
                
                // Define the three possible pairings for 4 players
                // Pairing 1: [0,3] vs [1,2] (player1&player4 vs player2&player3)
                // Pairing 2: [0,1] vs [2,3] (player1&player2 vs player3&player4)
                // Pairing 3: [0,2] vs [1,3] (player1&player3 vs player2&player4)
                const pairing1 = {
                    team1: [courtPlayers[0], courtPlayers[3]],
                    team2: [courtPlayers[1], courtPlayers[2]]
                };
                const pairing2 = {
                    team1: [courtPlayers[0], courtPlayers[1]],
                    team2: [courtPlayers[2], courtPlayers[3]]
                };
                const pairing3 = {
                    team1: [courtPlayers[0], courtPlayers[2]],
                    team2: [courtPlayers[1], courtPlayers[3]]
                };
                
                // Pattern:
                // Games 1-2: pairing1 (twice)
                // Games 3-4: pairing2 (twice)
                // Games 5-6: pairing3 (twice)
                // Games 7-9: cycle through pairings 1, 2, 3 (once each)
                // Games 10+: repeat the 7-9 cycle
                
                if (gameNumber <= 2) {
                    // Games 1-2: pairing1
                    return pairing1;
                } else if (gameNumber <= 4) {
                    // Games 3-4: pairing2
                    return pairing2;
                } else if (gameNumber <= 6) {
                    // Games 5-6: pairing3
                    return pairing3;
                } else {
                    // Games 7+: cycle through pairings
                    // Game 7, 10, 13, ... = pairing1
                    // Game 8, 11, 14, ... = pairing2
                    // Game 9, 12, 15, ... = pairing3
                    const cyclePosition = ((gameNumber - 7) % 3);
                    if (cyclePosition === 0) {
                        return pairing1;
                    } else if (cyclePosition === 1) {
                        return pairing2;
                    } else {
                        return pairing3;
                    }
                }
            }

            // Fallback matchup generator
            function generateFallbackMatchup(courtPlayers) {
                // Simple pairing: first two vs last two
                return {
                    team1: [courtPlayers[0], courtPlayers[1]],
                    team2: [courtPlayers[2], courtPlayers[3]]
                };
            }

            // Generate new courts - sort by points and reassign
            function generateNewCourts() {
                if (sessions.length === 0) {
                    showToast('Please initialize season first', true);
                    return;
                }

                // Calculate current points for all players
                const playerPoints = {};
                players.forEach(player => {
                    playerPoints[player.id] = 0;
                });

                sessions.forEach(session => {
                    session.matches.forEach(match => {
                        const team1Score = parseInt(match.team1Score) || 0;
                        const team2Score = parseInt(match.team2Score) || 0;
                        
                        match.team1.forEach(playerId => {
                            playerPoints[playerId] += team1Score;
                        });
                        match.team2.forEach(playerId => {
                            playerPoints[playerId] += team2Score;
                        });
                    });
                });

                // Sort players by points (descending)
                const sortedPlayers = [...players].sort((a, b) => {
                    return playerPoints[b.id] - playerPoints[a.id];
                });

                // Create new session with court assignments based on points
                const sessionId = currentSessionId++;
                const courtAssignments = [];
                const matches = [];

                // Assign top 4 to court 1, next 4 to court 2, etc.
                for (let court = 0; court < numCourts; court++) {
                    const courtPlayers = [];
                    for (let i = 0; i < 4; i++) {
                        const playerIndex = sortedPlayers[court * 4 + i].id;
                        courtPlayers.push(playerIndex);
                    }
                    courtAssignments.push(courtPlayers);

                    // Create first match: (0&3) vs (1&2) pattern
                    const team1 = [courtPlayers[0], courtPlayers[3]];
                    const team2 = [courtPlayers[1], courtPlayers[2]];
                    matches.push({
                        court: court,
                        team1: team1,
                        team2: team2,
                        team1Score: '',
                        team2Score: ''
                    });
                }

                sessions.push({
                    sessionId: sessionId,
                    date: getCurrentDate(),
                    courtAssignments: courtAssignments,
                    matches: matches
                });

                // Initialize teammate tracking for new session
                initializeSessionTeammateTracking(sessionId, courtAssignments);

                // Record initial teammate pairings
                matches.forEach(match => {
                    recordTeammatePairing(sessionId, match.court, match.team1);
                    recordTeammatePairing(sessionId, match.court, match.team2);
                });

                renderAllSessions();
                updateMatchStatus();
                updateStats();

                showToast('New courts generated based on current standings!');
            }

            // Helper function to get player name by ID
            function getPlayerNameById(playerId) {
                const player = players.find(p => p.id === playerId);
                return player ? player.name : `Player ${playerId + 1}`;
            }

            // Helper function to get sub name for a player in a session
            function getSubName(sessionId, playerId) {
                if (!sessionSubs[sessionId]) return null;
                const sub = sessionSubs[sessionId].find(s => s.subbingFor === playerId);
                return sub ? sub.subName : null;
            }

            // Helper function to get the display name (sub name if exists, otherwise player name)
            function getDisplayName(sessionId, playerId) {
                const subName = getSubName(sessionId, playerId);
                if (subName) {
                    return subName; // Just return sub name, tooltip will show who they're subbing for
                }
                return getPlayerNameById(playerId);
            }

            // Helper function to get tooltip text for a player (shows sub info if applicable)
            function getPlayerTooltip(sessionId, playerId) {
                const subName = getSubName(sessionId, playerId);
                if (subName) {
                    return `Subbing for ${getPlayerNameById(playerId)}`;
                }
                return '';
            }

            // Helper function to get full display name for exports (includes sub info)
            function getFullDisplayName(sessionId, playerId) {
                const subName = getSubName(sessionId, playerId);
                if (subName) {
                    return `${subName} (subbing for ${getPlayerNameById(playerId)})`;
                }
                return getPlayerNameById(playerId);
            }

            // Create subs section for a session
            function createSubsSection(sessionId, courtAssignments) {
                const subsSection = document.createElement('div');
                subsSection.className = 'subs-section';
                
                // Get all players assigned to courts in this session
                const sessionPlayers = [];
                courtAssignments.forEach((courtPlayers, courtIndex) => {
                    courtPlayers.forEach(playerId => {
                        if (!sessionPlayers.find(p => p.id === playerId)) {
                            sessionPlayers.push({
                                id: playerId,
                                name: getPlayerNameById(playerId),
                                court: courtIndex
                            });
                        }
                    });
                });

                // Get existing subs for this session
                const existingSubs = sessionSubs[sessionId] || [];

                subsSection.innerHTML = `
                    <h4>Substitutes</h4>
                    <div class="add-sub-form">
                        <input type="text" id="sub-name-${sessionId}" placeholder="Sub name" />
                        <select id="sub-for-${sessionId}">
                            <option value="">Select player to sub for...</option>
                            ${sessionPlayers.map(p => `<option value="${p.id}">${p.name} (Court ${p.court + 1})</option>`).join('')}
                        </select>
                        <button onclick="addSub(${sessionId})">Add Sub</button>
                    </div>
                    <div class="subs-list" id="subs-list-${sessionId}">
                        ${existingSubs.map((sub, index) => `
                            <div class="sub-item">
                                <div class="sub-item-info">
                                    <span class="sub-item-name">${sub.subName}</span>
                                    <span class="sub-item-for">‚Üí subbing for ${getPlayerNameById(sub.subbingFor)} (Court ${sub.court + 1})</span>
                                </div>
                                <button onclick="removeSub(${sessionId}, ${index})">Remove</button>
                            </div>
                        `).join('')}
                    </div>
                `;

                return subsSection;
            }

            // Add a sub to a session
            function addSub(sessionId) {
                const subNameInput = document.getElementById(`sub-name-${sessionId}`);
                const subForSelect = document.getElementById(`sub-for-${sessionId}`);
                
                const subName = subNameInput.value.trim();
                const subbingFor = parseInt(subForSelect.value);

                if (!subName) {
                    showToast('Please enter a sub name', true);
                    return;
                }

                if (!subbingFor && subbingFor !== 0) {
                    showToast('Please select a player to sub for', true);
                    return;
                }

                // Find which court this player is on
                const session = sessions.find(s => s.sessionId === sessionId);
                if (!session) {
                    showToast('Session not found', true);
                    return;
                }

                let playerCourt = -1;
                session.courtAssignments.forEach((courtPlayers, courtIndex) => {
                    if (courtPlayers.includes(subbingFor)) {
                        playerCourt = courtIndex;
                    }
                });

                if (playerCourt === -1) {
                    showToast('Player not found in session', true);
                    return;
                }

                // Check if this player already has a sub
                if (!sessionSubs[sessionId]) {
                    sessionSubs[sessionId] = [];
                }

                const existingSubIndex = sessionSubs[sessionId].findIndex(s => s.subbingFor === subbingFor);
                if (existingSubIndex !== -1) {
                    showToast('This player already has a sub. Remove it first to add a new one.', true);
                    return;
                }

                // Add the sub
                sessionSubs[sessionId].push({
                    subName: subName,
                    subbingFor: subbingFor,
                    court: playerCourt
                });

                // Clear inputs
                subNameInput.value = '';
                subForSelect.value = '';

                // Re-render to show the new sub
                renderAllSessions();
                updateStats();
                showToast(`Sub "${subName}" added successfully!`);
            }

            // Remove a sub from a session
            function removeSub(sessionId, subIndex) {
                if (!sessionSubs[sessionId] || !sessionSubs[sessionId][subIndex]) {
                    showToast('Sub not found', true);
                    return;
                }

                sessionSubs[sessionId].splice(subIndex, 1);
                if (sessionSubs[sessionId].length === 0) {
                    delete sessionSubs[sessionId];
                }

                renderAllSessions();
                updateStats();
                showToast('Sub removed successfully!');
            }

            // Render all sessions
            function renderAllSessions() {
                // Save existing scores before clearing
                const savedScores = saveScores();

                const tournamentSessions = document.getElementById('tournamentSessions');
                tournamentSessions.innerHTML = '';

                sessions.forEach((session, sessionIndex) => {
                    const sessionDiv = document.createElement('div');
                    sessionDiv.className = 'round';
                    const sessionDate = session.date || 'Date not set';
                    const isCollapsed = sessionCollapsedState[session.sessionId] || false;
                    
                    // Create header with toggle icon and export/print buttons
                    const headerDiv = document.createElement('div');
                    headerDiv.className = `session-header ${isCollapsed ? 'collapsed' : ''}`;
                    headerDiv.innerHTML = `
                        <div class="header-content">
                            <span>Session ${sessionIndex + 1} - ${sessionDate}</span>
                            <button class="export-btn" onclick="event.stopPropagation(); exportSessionData(${session.sessionId})" title="Export this session's data">üì§ Export</button>
                            <button class="print-btn" onclick="event.stopPropagation(); printSessionPDF(${session.sessionId})" title="Print/PDF this session">üñ®Ô∏è PDF</button>
                        </div>
                        <span class="toggle-icon">‚ñº</span>
                    `;
                    headerDiv.onclick = (e) => {
                        // Don't toggle if clicking on buttons
                        if (!e.target.closest('.export-btn') && !e.target.closest('.print-btn')) {
                            toggleSession(session.sessionId);
                        }
                    };
                    sessionDiv.appendChild(headerDiv);

                    // Add subs section
                    const subsSection = createSubsSection(session.sessionId, session.courtAssignments);
                    sessionDiv.appendChild(subsSection);

                    const matchesDiv = document.createElement('div');
                    matchesDiv.className = `matches session-matches ${isCollapsed ? 'collapsed' : ''}`;

                    // Group matches by court for this session
                    const matchesByCourt = {};
                    session.matches.forEach(match => {
                        if (!matchesByCourt[match.court]) {
                            matchesByCourt[match.court] = [];
                        }
                        matchesByCourt[match.court].push(match);
                    });

                    // Render matches grouped by court
                    Object.keys(matchesByCourt).sort((a, b) => parseInt(a) - parseInt(b)).forEach(courtNum => {
                        const courtMatches = matchesByCourt[courtNum];
                        const courtDiv = document.createElement('div');
                        courtDiv.className = 'match';
                        courtDiv.innerHTML = `<h4>Court ${parseInt(courtNum) + 1}</h4>`;

                        courtMatches.forEach((match, matchIndex) => {
                            const matchKey = `${session.sessionId}-${match.court}-${matchIndex}`;
                            const team0Key = `${matchKey}-0`;
                            const team1Key = `${matchKey}-1`;
                            const team0Score = savedScores[team0Key] || match.team1Score || '';
                            const team1Score = savedScores[team1Key] || match.team2Score || '';

                            // Alternate background colors for matches
                            const isEven = matchIndex % 2 === 0;
                            const backgroundColor = isEven ? '#f8f9fa' : '#e9ecef';
                            const borderColor = isEven ? '#ddd' : '#bbb';

                            const matchElement = document.createElement('div');
                            matchElement.className = 'match-game';
                            matchElement.style.marginBottom = matchIndex < courtMatches.length - 1 ? '20px' : '0';
                            matchElement.style.padding = '12px';
                            matchElement.style.border = `2px solid ${borderColor}`;
                            matchElement.style.borderRadius = '5px';
                            matchElement.style.backgroundColor = backgroundColor;
                            matchElement.style.position = 'relative';
                            
                            // Build HTML with match label
                            matchElement.innerHTML = `
                                <div style="position: absolute; top: -10px; left: 10px; background-color: #2c5aa0; color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: bold;">
                                    Match ${matchIndex + 1}
                                </div>
                                <div style="margin-top: 8px;">
                                    <div class="team">
                                        <span class="team-names">
                                            <span class="player-display" data-session="${session.sessionId}" data-players="${match.team1[0]},${match.team1[1]}"></span>
                                        </span>
                                        <input type="number" class="score-input" data-session="${session.sessionId}" data-court="${match.court}" data-match="${matchIndex}" data-team="0" placeholder="Score" value="${team0Score}" />
                                    </div>
                                    <div class="vs">VS</div>
                                    <div class="team">
                                        <span class="team-names">
                                            <span class="player-display" data-session="${session.sessionId}" data-players="${match.team2[0]},${match.team2[1]}"></span>
                                        </span>
                                        <input type="number" class="score-input" data-session="${session.sessionId}" data-court="${match.court}" data-match="${matchIndex}" data-team="1" placeholder="Score" value="${team1Score}" />
                                    </div>
                                </div>
                            `;
                            courtDiv.appendChild(matchElement);
                        });

                        matchesDiv.appendChild(courtDiv);
                    });

                    sessionDiv.appendChild(matchesDiv);
                    tournamentSessions.appendChild(sessionDiv);
                });

                // Add event listeners to score inputs
                document.querySelectorAll('.score-input').forEach((input) => {
                    input.addEventListener('input', (e) => {
                        const sessionId = parseInt(e.target.getAttribute('data-session'));
                        const court = parseInt(e.target.getAttribute('data-court'));
                        const matchIndex = parseInt(e.target.getAttribute('data-match'));
                        const team = parseInt(e.target.getAttribute('data-team'));
                        const score = e.target.value;

                        const session = sessions.find(s => s.sessionId === sessionId);
                        if (session) {
                            // Find matches for this court
                            const courtMatches = session.matches.filter(m => m.court === court);
                            const match = courtMatches[matchIndex];
                            if (match) {
                                if (team === 0) {
                                    match.team1Score = score;
                                } else {
                                    match.team2Score = score;
                                }
                            }
                        }
                        updateStats();
                    });
                });

                // Update player displays
                updatePlayerDisplays();
            }

            // Toggle session collapse/expand
            function toggleSession(sessionId) {
                // Toggle the collapsed state
                sessionCollapsedState[sessionId] = !sessionCollapsedState[sessionId];
                // Re-render to apply the change
                renderAllSessions();
            }

            // Save current scores before re-rendering
            function saveScores() {
                const scores = {};
                document.querySelectorAll('.score-input').forEach((input) => {
                    const sessionId = input.getAttribute('data-session');
                    const court = input.getAttribute('data-court');
                    const matchIndex = input.getAttribute('data-match');
                    const teamIndex = input.getAttribute('data-team');
                    const key = `${sessionId}-${court}-${matchIndex}-${teamIndex}`;
                    scores[key] = input.value;
                });
                return scores;
            }

            // Update match status
            function updateMatchStatus() {
                const statusElement = document.getElementById('matchStatus');
                const totalMatches = sessions.reduce((sum, session) => sum + session.matches.length, 0);
                statusElement.textContent = `Total matches: ${totalMatches} | Sessions: ${sessions.length}`;
            }

            // Generate summary section
            function generateSummarySection() {
                const summaryGrid = document.getElementById('summaryGrid');
                summaryGrid.innerHTML = '';

                players.forEach((player, index) => {
                    const summaryDiv = document.createElement('div');
                    summaryDiv.className = 'summary-item';
                    summaryDiv.id = `summary-${player.id}`;
                    summaryDiv.innerHTML = `
                        <div class="rank-badge" id="rank-badge-${player.id}">${index + 1}</div>
                        <div class="player-name">${player.name}</div>
                        <div class="points">0 Points</div>
                        <div class="rank" id="rank-${player.id}">${index + 1}th Place</div>
                    `;
                    summaryGrid.appendChild(summaryDiv);
                });
            }

            // Update player display when names are entered
            function updatePlayerDisplays() {
                // Update all player displays in matches
                document.querySelectorAll('.player-display').forEach((display) => {
                    const sessionId = parseInt(display.getAttribute('data-session'));
                    const playerNumbers = display.getAttribute('data-players').split(',');
                    const playerNames = playerNumbers.map((num) => {
                        const playerId = parseInt(num);
                        return getDisplayName(sessionId, playerId);
                    });
                    
                    // Build tooltip text for both players
                    const tooltips = playerNumbers.map((num) => {
                        const playerId = parseInt(num);
                        return getPlayerTooltip(sessionId, playerId);
                    }).filter(t => t); // Remove empty tooltips
                    
                    display.textContent = playerNames.join(' & ');
                    
                    // Add tooltip if any player has a sub
                    if (tooltips.length > 0) {
                        display.setAttribute('title', tooltips.join(' | '));
                        display.style.cursor = 'help';
                    } else {
                        display.removeAttribute('title');
                        display.style.cursor = '';
                    }
                });
            }

            // Update stats
            function updateStats() {
                const playerStats = {};

                // Initialize stats for all players
                players.forEach(player => {
                    playerStats[player.id] = {
                        points: 0,
                        playerId: player.id
                    };
                });

                // Process each match
                sessions.forEach(session => {
                    session.matches.forEach(match => {
                        const team1Score = parseInt(match.team1Score) || 0;
                        const team2Score = parseInt(match.team2Score) || 0;

                        // Add points to each player on both teams
                        match.team1.forEach((playerId) => {
                            playerStats[playerId].points += team1Score;
                        });
                        match.team2.forEach((playerId) => {
                            playerStats[playerId].points += team2Score;
                        });
                    });
                });

                // Sort players by points (descending)
                const sortedPlayers = Object.values(playerStats).sort((a, b) => {
                    return b.points - a.points;
                });

                // Get the summary grid container
                const summaryGrid = document.getElementById('summaryGrid');
                summaryGrid.innerHTML = '';

                // Re-create summary items in ranked order
                sortedPlayers.forEach((player, index) => {
                    const place = index + 1;
                    let placeText;
                    if (place === 1) placeText = '1st Place';
                    else if (place === 2) placeText = '2nd Place';
                    else if (place === 3) placeText = '3rd Place';
                    else placeText = `${place}th Place`;

                    // Determine rank badge class
                    let rankBadgeClass = 'rank-badge';
                    let summaryItemClass = 'summary-item';
                    if (index === 0) {
                        rankBadgeClass += ' first';
                        summaryItemClass += ' winner';
                    } else if (index === 1) {
                        rankBadgeClass += ' second';
                        summaryItemClass += ' second';
                    } else if (index === 2) {
                        rankBadgeClass += ' third';
                        summaryItemClass += ' third';
                    }

                    const playerObj = players.find(p => p.id === player.playerId);
                    const playerName = playerObj ? playerObj.name : `Player ${player.playerId + 1}`;

                    // Create new summary item
                    const summaryDiv = document.createElement('div');
                    summaryDiv.className = summaryItemClass;
                    summaryDiv.id = `summary-${player.playerId}`;
                    summaryDiv.innerHTML = `
                        <div class="${rankBadgeClass}" id="rank-badge-${player.playerId}">${place}</div>
                        <div class="player-name">${playerName}</div>
                        <div class="points">${player.points} Points</div>
                        <div class="rank" id="rank-${player.playerId}">${placeText}</div>
                    `;
                    summaryGrid.appendChild(summaryDiv);
                });
            }

            // Toast notification function
            function showToast(message, isError = false) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast ${isError ? 'error' : ''}`;
                toast.classList.add('show');

                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }

            // Get saved seasons from localStorage
            function getSavedSeasons() {
                try {
                    const saved = localStorage.getItem('savedSeasons');
                    return saved ? JSON.parse(saved) : {};
                } catch (e) {
                    console.error('Error reading saved seasons:', e);
                    return {};
                }
            }

            // Save seasons to localStorage
            function setSavedSeasons(seasons) {
                try {
                    localStorage.setItem('savedSeasons', JSON.stringify(seasons));
                } catch (e) {
                    console.error('Error saving seasons:', e);
                    showToast('Error saving to local storage. Storage may be full.', true);
                }
            }

            // Save season data to localStorage
            function saveToLocalStorage() {
                if (sessions.length === 0) {
                    showToast('No season data to save', true);
                    return;
                }

                const seasonName = prompt('Enter a name for this season:');
                if (!seasonName || seasonName.trim() === '') {
                    showToast('Season name is required', true);
                    return;
                }

                const seasonData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    seasonName: seasonName.trim(),
                    numCourts: numCourts,
                    playerCount: currentPlayerCount,
                    players: players.map(p => ({ id: p.id, name: p.name })),
                    sessions: sessions.map(session => ({
                        sessionId: session.sessionId,
                        date: session.date || getCurrentDate(),
                        courtAssignments: session.courtAssignments,
                        matches: session.matches.map(match => ({
                            court: match.court,
                            team1: match.team1,
                            team2: match.team2,
                            team1Score: match.team1Score || '',
                            team2Score: match.team2Score || ''
                        }))
                    })),
                    sessionSubs: sessionSubs
                };

                const savedSeasons = getSavedSeasons();
                savedSeasons[seasonName.trim()] = seasonData;
                setSavedSeasons(savedSeasons);

                showToast(`Season "${seasonName.trim()}" saved successfully!`);
            }

            // Show load season dialog
            function showLoadSeasonDialog() {
                const dialog = document.getElementById('loadSeasonDialog');
                const list = document.getElementById('savedSeasonsList');
                
                const savedSeasons = getSavedSeasons();
                const seasonNames = Object.keys(savedSeasons).sort();

                if (seasonNames.length === 0) {
                    list.innerHTML = '<p style="color: #666;">No saved seasons found.</p>';
                } else {
                    list.innerHTML = '';
                    seasonNames.forEach(name => {
                        const season = savedSeasons[name];
                        const seasonDiv = document.createElement('div');
                        seasonDiv.style.cssText = 'padding: 15px; margin: 10px 0; border: 1px solid #ddd; border-radius: 5px; background-color: #f8f9fa;';
                        seasonDiv.innerHTML = `
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="color: #2c5aa0;">${name}</strong>
                                    <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                                        ${season.numCourts} court(s) ‚Ä¢ ${season.sessions.length} session(s) ‚Ä¢ Saved: ${new Date(season.timestamp).toLocaleDateString()}
                                    </div>
                                </div>
                                <div>
                                    <button class="btn" onclick="loadSeasonFromStorage('${name}')" style="background-color: #20c997; color: white; margin-right: 5px;">Load</button>
                                    <button class="btn" onclick="deleteSeasonFromStorage('${name}')" style="background-color: #dc3545; color: white;">Delete</button>
                                </div>
                            </div>
                        `;
                        list.appendChild(seasonDiv);
                    });
                }

                dialog.style.display = 'flex';
            }

            // Hide load season dialog
            function hideLoadSeasonDialog() {
                document.getElementById('loadSeasonDialog').style.display = 'none';
            }

            // Load season from localStorage
            function loadSeasonFromStorage(seasonName) {
                const savedSeasons = getSavedSeasons();
                const seasonData = savedSeasons[seasonName];

                if (!seasonData) {
                    showToast('Season not found', true);
                    return;
                }

                // Confirm before loading (will overwrite current data)
                if (!confirm(`Load season "${seasonName}"? This will replace your current season data.`)) {
                    return;
                }

                try {
                    // Load data
                    numCourts = seasonData.numCourts;
                    currentPlayerCount = seasonData.playerCount;
                    players = seasonData.players.map(p => ({ id: p.id, name: p.name }));
                    sessions = seasonData.sessions.map(session => ({
                        sessionId: session.sessionId,
                        date: session.date || 'Date not set',
                        courtAssignments: session.courtAssignments,
                        matches: session.matches.map(match => ({
                            court: match.court,
                            team1: match.team1,
                            team2: match.team2,
                            team1Score: match.team1Score || '',
                            team2Score: match.team2Score || ''
                        }))
                    }));

                    // Update current session ID
                    if (sessions.length > 0) {
                        currentSessionId = Math.max(...sessions.map(s => s.sessionId)) + 1;
                    } else {
                        currentSessionId = 0;
                    }

                    // Load subs
                    sessionSubs = seasonData.sessionSubs || {};

                    // Rebuild teammate tracking
                    currentSessionTeammateCounts = {};
                    sessions.forEach(session => {
                        initializeSessionTeammateTracking(session.sessionId, session.courtAssignments);
                        session.matches.forEach(match => {
                            recordTeammatePairing(session.sessionId, match.court, match.team1);
                            recordTeammatePairing(session.sessionId, match.court, match.team2);
                        });
                    });

                    // Update UI
                    document.getElementById('numCourts').value = numCourts;
                    document.getElementById('playerCountDisplay').textContent = `${currentPlayerCount} players`;
                    document.getElementById('playerSection').style.display = 'block';
                    document.getElementById('matchControls').style.display = 'block';

                    generatePlayerInputs();
                    renderAllSessions();
                    generateSummarySection();
                    updateMatchStatus();
                    updateStats();

                    hideLoadSeasonDialog();
                    showToast(`Season "${seasonName}" loaded successfully!`);
                } catch (error) {
                    console.error('Load error:', error);
                    showToast('Error loading season data', true);
                }
            }

            // Delete season from localStorage
            function deleteSeasonFromStorage(seasonName) {
                if (!confirm(`Delete season "${seasonName}"? This action cannot be undone.`)) {
                    return;
                }

                const savedSeasons = getSavedSeasons();
                delete savedSeasons[seasonName];
                setSavedSeasons(savedSeasons);

                // Refresh the dialog
                showLoadSeasonDialog();
                showToast(`Season "${seasonName}" deleted successfully!`);
            }

            // Export season data
            function exportData() {
                if (sessions.length === 0) {
                    showToast('No season data to export', true);
                    return;
                }

                const exportData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    numCourts: numCourts,
                    playerCount: currentPlayerCount,
                    players: players.map(p => ({ id: p.id, name: p.name })),
                    sessions: sessions.map(session => ({
                        sessionId: session.sessionId,
                        date: session.date || getCurrentDate(),
                        courtAssignments: session.courtAssignments,
                        matches: session.matches.map(match => ({
                            court: match.court,
                            team1: match.team1,
                            team2: match.team2,
                            team1Score: match.team1Score || '',
                            team2Score: match.team2Score || ''
                        }))
                    })),
                    sessionSubs: sessionSubs
                };

                // Create and download file
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);

                const link = document.createElement('a');
                link.href = url;
                link.download = `pickleball-season-${numCourts}courts-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                showToast('Season data exported successfully!');
            }

            // Export a single session's data
            function exportSessionData(sessionId) {
                const session = sessions.find(s => s.sessionId === sessionId);
                if (!session) {
                    showToast('Session not found', true);
                    return;
                }

                // Get session index for filename
                const sessionIndex = sessions.findIndex(s => s.sessionId === sessionId);
                const sessionDate = session.date || getCurrentDate();
                
                // Create a helper function to get player name by ID
                const getPlayerName = (playerId) => {
                    const player = players.find(p => p.id === playerId);
                    return player ? player.name : `Player ${playerId + 1}`;
                };

                // Build export data with player names for easier third-party integration
                const exportData = {
                    version: '1.0',
                    exportType: 'single-session',
                    timestamp: new Date().toISOString(),
                    session: {
                        sessionId: session.sessionId,
                        sessionNumber: sessionIndex + 1,
                        date: sessionDate,
                        numCourts: numCourts,
                        courtAssignments: session.courtAssignments.map((courtPlayers, courtIndex) => ({
                            court: courtIndex + 1,
                            players: courtPlayers.map(playerId => {
                                const sub = sessionSubs[sessionId]?.find(s => s.subbingFor === playerId);
                                return {
                                    id: playerId,
                                    name: getPlayerName(playerId),
                                    sub: sub ? {
                                        name: sub.subName,
                                        subbingFor: playerId
                                    } : null
                                };
                            })
                        })),
                        matches: session.matches.map((match, matchIndex) => {
                            const team1Names = match.team1.map(id => {
                                const sub = sessionSubs[sessionId]?.find(s => s.subbingFor === id);
                                return sub ? `${sub.subName} (subbing for ${getPlayerName(id)})` : getPlayerName(id);
                            });
                            const team2Names = match.team2.map(id => {
                                const sub = sessionSubs[sessionId]?.find(s => s.subbingFor === id);
                                return sub ? `${sub.subName} (subbing for ${getPlayerName(id)})` : getPlayerName(id);
                            });
                            
                            return {
                                matchNumber: matchIndex + 1,
                                court: match.court + 1,
                                team1: {
                                    players: match.team1.map(id => {
                                        const sub = sessionSubs[sessionId]?.find(s => s.subbingFor === id);
                                        return {
                                            id: id,
                                            name: getPlayerName(id),
                                            sub: sub ? {
                                                name: sub.subName,
                                                subbingFor: id
                                            } : null,
                                            displayName: sub ? `${sub.subName} (subbing for ${getPlayerName(id)})` : getPlayerName(id)
                                        };
                                    }),
                                    playerNames: team1Names.join(' & '),
                                    score: match.team1Score || ''
                                },
                                team2: {
                                    players: match.team2.map(id => {
                                        const sub = sessionSubs[sessionId]?.find(s => s.subbingFor === id);
                                        return {
                                            id: id,
                                            name: getPlayerName(id),
                                            sub: sub ? {
                                                name: sub.subName,
                                                subbingFor: id
                                            } : null,
                                            displayName: sub ? `${sub.subName} (subbing for ${getPlayerName(id)})` : getPlayerName(id)
                                        };
                                    }),
                                    playerNames: team2Names.join(' & '),
                                    score: match.team2Score || ''
                                },
                                result: match.team1Score && match.team2Score ? 
                                    (parseInt(match.team1Score) > parseInt(match.team2Score) ? 
                                        `${team1Names.join(' & ')} won` : 
                                        `${team2Names.join(' & ')} won`) : 
                                    'No score recorded'
                            };
                        }),
                        subs: sessionSubs[sessionId] || []
                    },
                    // Include full player list for reference
                    allPlayers: players.map(p => ({ id: p.id, name: p.name }))
                };

                // Create and download file
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);

                // Create filename with session number and date
                const dateStr = sessionDate.replace(/[^a-zA-Z0-9]/g, '-');
                const link = document.createElement('a');
                link.href = url;
                link.download = `pickleball-session-${sessionIndex + 1}-${dateStr}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                showToast(`Session ${sessionIndex + 1} data exported successfully!`);
            }

            // Print/PDF a single session
            function printSessionPDF(sessionId) {
                const session = sessions.find(s => s.sessionId === sessionId);
                if (!session) {
                    showToast('Session not found', true);
                    return;
                }

                const sessionIndex = sessions.findIndex(s => s.sessionId === sessionId);
                const sessionDate = session.date || 'Date not set';

                // Helper function to get player name by ID
                const getPlayerName = (playerId) => {
                    const player = players.find(p => p.id === playerId);
                    return player ? player.name : `Player ${playerId + 1}`;
                };

                // Calculate points for this session only
                const sessionPlayerPoints = {};
                players.forEach(player => {
                    sessionPlayerPoints[player.id] = 0;
                });

                session.matches.forEach(match => {
                    const team1Score = parseInt(match.team1Score) || 0;
                    const team2Score = parseInt(match.team2Score) || 0;
                    match.team1.forEach(playerId => {
                        sessionPlayerPoints[playerId] += team1Score;
                    });
                    match.team2.forEach(playerId => {
                        sessionPlayerPoints[playerId] += team2Score;
                    });
                });

                const sortedPlayers = [...players].sort((a, b) => sessionPlayerPoints[b.id] - sessionPlayerPoints[a.id]);

                // Build the session HTML
                let sessionHTML = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Session ${sessionIndex + 1} - ${sessionDate}</title>
    <style>
        @media print {
            body { margin: 0; padding: 20px; }
            .no-print { display: none; }
            .page-break { page-break-after: always; }
        }
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
        }
        h3 {
            color: #7f8c8d;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        .session-info {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 20px;
            font-size: 0.95em;
        }
        .match-result {
            margin: 15px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .court-header {
            font-weight: bold;
            color: #3498db;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        .team {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            background-color: white;
            border-radius: 3px;
        }
        .score {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
        }
        .vs {
            text-align: center;
            margin: 5px 0;
            font-weight: bold;
            color: #7f8c8d;
        }
        .standings-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .standings-table th,
        .standings-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .standings-table th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }
        .standings-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .standings-table tr:first-child {
            background-color: #d4edda;
        }
        .court-section {
            margin-bottom: 25px;
        }
        .match-number {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <h1>üèì Pickleball Session ${sessionIndex + 1}</h1>
    <div class="session-info">
        <strong>Date:</strong> ${sessionDate}<br>
        <strong>Generated:</strong> ${new Date().toLocaleString()}<br>
        <strong>Total Matches:</strong> ${session.matches.length}
    </div>
`;

                // Add matches grouped by court
                sessionHTML += '<h2>Match Results</h2>\n';
                
                const matchesByCourt = {};
                session.matches.forEach(match => {
                    if (!matchesByCourt[match.court]) {
                        matchesByCourt[match.court] = [];
                    }
                    matchesByCourt[match.court].push(match);
                });

                Object.keys(matchesByCourt).sort((a, b) => parseInt(a) - parseInt(b)).forEach(courtNum => {
                    const courtMatches = matchesByCourt[courtNum];
                    sessionHTML += `<div class="court-section">\n`;
                    sessionHTML += `<div class="court-header">Court ${parseInt(courtNum) + 1}</div>\n`;
                    
                    // Get court players
                    const courtPlayers = session.courtAssignments[parseInt(courtNum)];
                    const playerNames = courtPlayers.map(id => getFullDisplayName(sessionId, id)).join(', ');
                    sessionHTML += `<div style="font-size: 0.9em; color: #7f8c8d; margin-bottom: 10px;">Players: ${playerNames}</div>\n`;
                    
                    courtMatches.forEach((match, matchIndex) => {
                        const team1Names = `${getFullDisplayName(sessionId, match.team1[0])} & ${getFullDisplayName(sessionId, match.team1[1])}`;
                        const team2Names = `${getFullDisplayName(sessionId, match.team2[0])} & ${getFullDisplayName(sessionId, match.team2[1])}`;
                        const team1Score = parseInt(match.team1Score) || 0;
                        const team2Score = parseInt(match.team2Score) || 0;
                        
                        sessionHTML += `
    <div class="match-result">
        <div class="match-number">Match ${matchIndex + 1}</div>
        <div class="team">
            <span>${team1Names}</span>
            <span class="score">${team1Score}</span>
        </div>
        <div class="vs">VS</div>
        <div class="team">
            <span>${team2Names}</span>
            <span class="score">${team2Score}</span>
        </div>
    </div>
`;
                    });
                    
                    sessionHTML += '</div>\n';
                });

                // Add session standings
                sessionHTML += '<h2>Session Standings</h2>\n';
                sessionHTML += `
    <table class="standings-table">
        <thead>
            <tr>
                <th>Rank</th>
                <th>Player</th>
                <th>Points</th>
            </tr>
        </thead>
        <tbody>
`;

                sortedPlayers.forEach((player, index) => {
                    const place = index + 1;
                    sessionHTML += `
            <tr>
                <td>${place}</td>
                <td>${player.name}</td>
                <td>${sessionPlayerPoints[player.id]}</td>
            </tr>
`;
                });

                sessionHTML += `
        </tbody>
    </table>
    <div class="no-print" style="text-align: center; margin: 20px 0;">
        <button onclick="window.print()" style="background-color: #3498db; color: white; border: none; padding: 12px 24px; font-size: 16px; border-radius: 5px; cursor: pointer;">üñ®Ô∏è Print / Save as PDF</button>
    </div>
</body>
</html>
`;

                // Open in new window and print
                const printWindow = window.open('', '_blank');
                printWindow.document.write(sessionHTML);
                printWindow.document.close();
                
                // Wait for content to load, then trigger print dialog
                printWindow.onload = function() {
                    setTimeout(() => {
                        printWindow.print();
                    }, 250);
                };

                showToast(`Session ${sessionIndex + 1} PDF ready for printing!`);
            }

            // Import season data
            function importData(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const seasonData = JSON.parse(e.target.result);

                        // Validate data structure
                        if (!seasonData.players || !seasonData.sessions || seasonData.numCourts === undefined) {
                            throw new Error('Invalid season data format');
                        }

                        // Load data
                        numCourts = seasonData.numCourts;
                        currentPlayerCount = seasonData.playerCount;
                        players = seasonData.players.map(p => ({ id: p.id, name: p.name }));
                        sessions = seasonData.sessions.map(session => ({
                            sessionId: session.sessionId,
                            date: session.date || 'Date not set',
                            courtAssignments: session.courtAssignments,
                            matches: session.matches.map(match => ({
                                court: match.court,
                                team1: match.team1,
                                team2: match.team2,
                                team1Score: match.team1Score || '',
                                team2Score: match.team2Score || ''
                            }))
                        }));

                        // Update current session ID
                        if (sessions.length > 0) {
                            currentSessionId = Math.max(...sessions.map(s => s.sessionId)) + 1;
                        } else {
                            currentSessionId = 0;
                        }

                        // Load subs
                        sessionSubs = seasonData.sessionSubs || {};

                        // Rebuild teammate tracking
                        currentSessionTeammateCounts = {};
                        sessions.forEach(session => {
                            initializeSessionTeammateTracking(session.sessionId, session.courtAssignments);
                            session.matches.forEach(match => {
                                recordTeammatePairing(session.sessionId, match.court, match.team1);
                                recordTeammatePairing(session.sessionId, match.court, match.team2);
                            });
                        });

                        // Update UI
                        document.getElementById('numCourts').value = numCourts;
                        document.getElementById('playerCountDisplay').textContent = `${currentPlayerCount} players`;
                        document.getElementById('playerSection').style.display = 'block';
                        document.getElementById('matchControls').style.display = 'block';

                        generatePlayerInputs();
                        renderAllSessions();
                        generateSummarySection();
                        updateMatchStatus();
                        updateStats();

                        showToast('Season data imported successfully!');
                    } catch (error) {
                        console.error('Import error:', error);
                        showToast('Error importing season data. Please check the file format.', true);
                    }
                };

                reader.readAsText(file);
                event.target.value = '';
            }

            // Clear all data
            function clearAllData() {
                if (confirm('Are you sure you want to clear all season data? This action cannot be undone.')) {
                    // Clear player names
                    players.forEach((player, index) => {
                        const input = document.getElementById(`player${index}`);
                        if (input) input.value = '';
                    });

                    // Reset data
                    sessions = [];
                    currentSessionId = 0;
                    currentSessionTeammateCounts = {};
                    sessionCollapsedState = {};
                    sessionSubs = {};

                    // Update displays
                    renderAllSessions();
                    updateStats();
                    updateMatchStatus();

                    showToast('All season data cleared!');
                }
            }

            // Print season summary
            function printSeasonSummary() {
                if (sessions.length === 0) {
                    showToast('No season data to print', true);
                    return;
                }

                // Calculate player points
                const playerPoints = {};
                players.forEach(player => {
                    playerPoints[player.id] = 0;
                });

                sessions.forEach(session => {
                    session.matches.forEach(match => {
                        const team1Score = parseInt(match.team1Score) || 0;
                        const team2Score = parseInt(match.team2Score) || 0;
                        match.team1.forEach(playerId => {
                            playerPoints[playerId] += team1Score;
                        });
                        match.team2.forEach(playerId => {
                            playerPoints[playerId] += team2Score;
                        });
                    });
                });

                const sortedPlayers = [...players].sort((a, b) => playerPoints[b.id] - playerPoints[a.id]);

                // Build the summary HTML
                let summaryHTML = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Season Summary</title>
    <style>
        @media print {
            body { margin: 0; padding: 20px; }
            .no-print { display: none; }
            .page-break { page-break-after: always; }
        }
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
        }
        h3 {
            color: #7f8c8d;
            margin-top: 20px;
        }
        .match-result {
            margin: 15px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .team {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            background-color: white;
            border-radius: 3px;
        }
        .score {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
        }
        .vs {
            text-align: center;
            margin: 5px 0;
            font-weight: bold;
            color: #7f8c8d;
        }
        .standings-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .standings-table th,
        .standings-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .standings-table th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }
        .standings-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .standings-table tr:first-child {
            background-color: #d4edda;
        }
        .session-section {
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <h1>üèì Pickleball Season Summary</h1>
    <p style="text-align: center; color: #7f8c8d;">
        Generated on ${new Date().toLocaleString()}
    </p>
`;

                // Add all sessions and matches
                summaryHTML += '<h2>Match Results</h2>\n';
                
                sessions.forEach((session, sessionIndex) => {
                    summaryHTML += `<div class="session-section">\n`;
                    const sessionDate = session.date || 'Date not set';
                    summaryHTML += `<h3>Session ${sessionIndex + 1} - ${sessionDate}</h3>\n`;
                    
                    // Group matches by court
                    const matchesByCourt = {};
                    session.matches.forEach(match => {
                        if (!matchesByCourt[match.court]) {
                            matchesByCourt[match.court] = [];
                        }
                        matchesByCourt[match.court].push(match);
                    });

                    Object.keys(matchesByCourt).sort((a, b) => parseInt(a) - parseInt(b)).forEach(courtNum => {
                        const courtMatches = matchesByCourt[courtNum];
                        courtMatches.forEach(match => {
                            const team1Names = `${players.find(p => p.id === match.team1[0]).name} & ${players.find(p => p.id === match.team1[1]).name}`;
                            const team2Names = `${players.find(p => p.id === match.team2[0]).name} & ${players.find(p => p.id === match.team2[1]).name}`;
                            const team1Score = parseInt(match.team1Score) || 0;
                            const team2Score = parseInt(match.team2Score) || 0;
                            
                            summaryHTML += `
    <div class="match-result">
        <div style="font-weight: bold; color: #3498db; margin-bottom: 5px;">Court ${parseInt(courtNum) + 1}</div>
        <div class="team">
            <span>${team1Names}</span>
            <span class="score">${team1Score}</span>
        </div>
        <div class="vs">VS</div>
        <div class="team">
            <span>${team2Names}</span>
            <span class="score">${team2Score}</span>
        </div>
    </div>
`;
                        });
                    });
                    
                    summaryHTML += '</div>\n';
                });

                // Add final standings
                summaryHTML += '<h2>Final Standings</h2>\n';
                summaryHTML += `
    <table class="standings-table">
        <thead>
            <tr>
                <th>Rank</th>
                <th>Player</th>
                <th>Points</th>
            </tr>
        </thead>
        <tbody>
`;

                sortedPlayers.forEach((player, index) => {
                    const place = index + 1;
                    summaryHTML += `
            <tr>
                <td>${place}</td>
                <td>${player.name}</td>
                <td>${playerPoints[player.id]}</td>
            </tr>
`;
                });

                summaryHTML += `
        </tbody>
    </table>
    <div class="no-print" style="text-align: center; margin: 20px 0;">
        <button onclick="window.print()" style="background-color: #3498db; color: white; border: none; padding: 12px 24px; font-size: 16px; border-radius: 5px; cursor: pointer;">üñ®Ô∏è Print Summary</button>
    </div>
</body>
</html>
`;

                // Open in new window and print
                const printWindow = window.open('', '_blank');
                printWindow.document.write(summaryHTML);
                printWindow.document.close();
                
                // Wait for content to load, then trigger print dialog
                printWindow.onload = function() {
                    setTimeout(() => {
                        printWindow.print();
                    }, 250);
                };

                showToast('Season summary opened in new window');
            }
        </script>
    </body>
</html>
