<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Pickleball Tournament - Dynamic Round Robin</title>
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <div class="container">
            <h1>🏓 Pickleball Tournament - Dynamic Round Robin</h1>

            <!-- Control Buttons -->
            <div class="controls">
                <button class="btn btn-export" onclick="exportData()">📤 Export Tournament Data</button>
                <button class="btn btn-import" onclick="document.getElementById('fileInput').click()">📥 Import Tournament Data</button>
                <button class="btn btn-clear" onclick="clearAllData()">🗑️ Clear All Data</button>
                <input type="file" id="fileInput" class="file-input" accept=".json" onchange="importData(event)" />
            </div>

            <!-- Player Count Section -->
            <div class="player-count-section">
                <h3>Tournament Setup</h3>
                <div class="player-count-input">
                    <label for="playerCount">Number of Players:</label>
                    <input type="number" id="playerCount" min="4" max="16" value="8" onchange="generateTournament()" />
                    <button class="btn btn-generate" onclick="generateTournament()">🔄 Generate Tournament</button>
                </div>
                <div class="info-text">
                    Tournament will have <span id="roundsCount">7</span> rounds with <span id="matchesPerRound">4</span> matches per round
                </div>
            </div>

            <!-- Player Names Section -->
            <div class="player-section">
                <h3>Player Names</h3>
                <div class="player-grid" id="playerGrid">
                    <!-- Player inputs will be generated dynamically -->
                </div>
            </div>

            <!-- Tournament Rounds -->
            <div id="tournamentRounds">
                <!-- Rounds will be generated dynamically -->
            </div>

            <!-- Summary Section -->
            <div class="summary-section">
                <h3>🏆 Tournament Standings</h3>
                <div class="summary-grid" id="summaryGrid">
                    <!-- Summary items will be generated dynamically -->
                </div>
            </div>
        </div>

        <!-- Toast notification -->
        <div id="toast" class="toast"></div>

        <script>
            let currentPlayerCount = 8;
            let matchConfigs = [];
            let playerStats = {};

            // Generate round robin schedule for doubles where each player plays with and against every other player exactly once
            function generateRoundRobinSchedule(numPlayers) {
                const schedule = [];
                
                // For doubles, we need an even number of players
                if (numPlayers % 2 !== 0) {
                    showToast('For doubles matches, please use an even number of players', true);
                    return [];
                }

                // Create all possible partnerships
                const allPartnerships = [];
                for (let i = 1; i <= numPlayers; i++) {
                    for (let j = i + 1; j <= numPlayers; j++) {
                        allPartnerships.push([i, j]);
                    }
                }
                
                // Shuffle partnerships for variety between attempts
                for (let i = allPartnerships.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allPartnerships[i], allPartnerships[j]] = [allPartnerships[j], allPartnerships[i]];
                }
                
                // Track used partnerships to prevent duplicates
                const usedPartnerships = new Set();
                const rounds = numPlayers - 1;
                
                for (let round = 0; round < rounds; round++) {
                    const roundMatches = [];
                    const usedPlayers = new Set();
                    const availablePartnerships = allPartnerships.filter(p => !usedPartnerships.has(`${p[0]}-${p[1]}`));
                    
                    // Try to create matches for this round
                    while (availablePartnerships.length > 0 && usedPlayers.size < numPlayers) {
                        let foundMatch = false;
                        
                        // Try to find two partnerships that don't share players
                        for (let i = 0; i < availablePartnerships.length; i++) {
                            const partnership1 = availablePartnerships[i];
                            
                            // Check if partnership1 players are already used in this round
                            const partnership1Used = partnership1.some(player => usedPlayers.has(player));
                            
                            if (!partnership1Used) {
                                // Find a second partnership that doesn't share any players with partnership1
                                for (let j = i + 1; j < availablePartnerships.length; j++) {
                                    const partnership2 = availablePartnerships[j];
                                    
                                    // Check if partnership2 players are already used in this round
                                    const partnership2Used = partnership2.some(player => usedPlayers.has(player));
                                    
                                    // Check if partnerships share any players
                                    const sharesPlayers = partnership1.some(player => partnership2.includes(player));
                                    
                                    if (!partnership2Used && !sharesPlayers) {
                                        // Found a valid match
                                        roundMatches.push([partnership1, partnership2]);
                                        
                                        // Mark players as used
                                        [...partnership1, ...partnership2].forEach(player => usedPlayers.add(player));
                                        
                                        // Mark partnerships as used
                                        usedPartnerships.add(`${partnership1[0]}-${partnership1[1]}`);
                                        usedPartnerships.add(`${partnership2[0]}-${partnership2[1]}`);
                                        
                                        // Remove used partnerships from available list
                                        availablePartnerships.splice(j, 1);
                                        availablePartnerships.splice(i, 1);
                                        foundMatch = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (foundMatch) break;
                        }
                        
                        if (!foundMatch) {
                            // Can't create more matches for this round
                            break;
                        }
                    }
                    
                    // Check if we used all players in this round
                    if (usedPlayers.size !== numPlayers) {
                        showToast('Could not generate a perfect tournament. Please try again.', true);
                        return [];
                    }
                    
                    if (roundMatches.length > 0) {
                        schedule.push(roundMatches);
                    }
                }
                
                return schedule;
            }

            // Generate tournament structure
            function generateTournament() {
                const playerCount = parseInt(document.getElementById('playerCount').value);
                if (playerCount < 4 || playerCount > 16) {
                    showToast('Please enter a number between 4 and 16 players', true);
                    return;
                }

                if (playerCount % 2 !== 0) {
                    showToast('For doubles matches, please use an even number of players', true);
                    return;
                }

                currentPlayerCount = playerCount;
                
                // Try to generate tournament, with automatic rerun if it fails
                let attempts = 0;
                const maxReruns = 10;
                
                do {
                    attempts++;
                    matchConfigs = generateRoundRobinSchedule(playerCount);
                    
                    // If we got 0 rounds, try again
                    if (matchConfigs.length === 0) {
                        console.log(`Tournament generation failed, attempt ${attempts}/${maxReruns}`);
                        if (attempts < maxReruns) {
                            showToast(`Generating tournament... (attempt ${attempts + 1}/${maxReruns})`);
                            continue;
                        } else {
                            showToast('Could not generate a valid tournament after multiple attempts. Please try again.', true);
                            return;
                        }
                    }
                } while (matchConfigs.length === 0 && attempts < maxReruns);

                // Update info text
                const roundsCount = matchConfigs.length;
                const matchesPerRound = Math.floor(playerCount / 4); // 4 players per match
                document.getElementById('roundsCount').textContent = roundsCount;
                document.getElementById('matchesPerRound').textContent = matchesPerRound;

                generatePlayerInputs();
                generateTournamentRounds();
                generateSummarySection();

                // Clear existing data
                clearScores();
                updatePlayerDisplays();
                updateStats();

                if (attempts > 1) {
                    showToast(`Doubles tournament generated for ${playerCount} players! (took ${attempts} attempts)`);
                } else {
                    showToast(`Doubles tournament generated for ${playerCount} players!`);
                }
            }

            // Generate player input fields
            function generatePlayerInputs() {
                const playerGrid = document.getElementById('playerGrid');
                playerGrid.innerHTML = '';

                for (let i = 1; i <= currentPlayerCount; i++) {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-input';
                    playerDiv.innerHTML = `
                        <label>Player ${i}</label>
                        <input type="text" id="player${i}" placeholder="Enter name" />
                    `;
                    playerGrid.appendChild(playerDiv);
                }

                // Add event listeners
                for (let i = 1; i <= currentPlayerCount; i++) {
                    const input = document.getElementById(`player${i}`);
                    if (input) {
                        input.addEventListener('input', updatePlayerDisplays);
                    }
                }
            }

            // Generate tournament rounds
            function generateTournamentRounds() {
                const tournamentRounds = document.getElementById('tournamentRounds');
                tournamentRounds.innerHTML = '';

                matchConfigs.forEach((round, roundIndex) => {
                    const roundDiv = document.createElement('div');
                    roundDiv.className = 'round';
                    roundDiv.innerHTML = `<h3>Round ${roundIndex + 1}</h3>`;

                    const matchesDiv = document.createElement('div');
                    matchesDiv.className = 'matches';

                    round.forEach((match, matchIndex) => {
                        const matchDiv = document.createElement('div');
                        matchDiv.className = 'match';
                        matchDiv.innerHTML = `
                            <h4>Court ${String.fromCharCode(65 + matchIndex)}</h4>
                            <div class="team">
                                <span class="team-names">
                                    <span class="player-display" data-players="${match[0][0]},${match[0][1]}"></span>
                                </span>
                                <input type="number" class="score-input" placeholder="Score" />
                            </div>
                            <div class="vs">VS</div>
                            <div class="team">
                                <span class="team-names">
                                    <span class="player-display" data-players="${match[1][0]},${match[1][1]}"></span>
                                </span>
                                <input type="number" class="score-input" placeholder="Score" />
                            </div>
                        `;
                        matchesDiv.appendChild(matchDiv);
                    });

                    roundDiv.appendChild(matchesDiv);
                    tournamentRounds.appendChild(roundDiv);
                });

                // Add event listeners to score inputs
                document.querySelectorAll('.score-input').forEach((input) => {
                    input.addEventListener('input', updateStats);
                });
            }

            // Generate summary section
            function generateSummarySection() {
                const summaryGrid = document.getElementById('summaryGrid');
                summaryGrid.innerHTML = '';

                for (let i = 1; i <= currentPlayerCount; i++) {
                    const summaryDiv = document.createElement('div');
                    summaryDiv.className = 'summary-item';
                    summaryDiv.id = `summary-${i}`;
                    summaryDiv.innerHTML = `
                        <div class="rank-badge" id="rank-badge-${i}">${i}</div>
                        <div class="player-name">Player ${i}</div>
                        <div class="wins">0 Wins</div>
                        <div class="points">0 Points</div>
                        <div class="rank" id="rank-${i}">${i}th Place</div>
                    `;
                    summaryGrid.appendChild(summaryDiv);
                }
            }

            // Clear all scores
            function clearScores() {
                document.querySelectorAll('.score-input').forEach((input) => {
                    input.value = '';
                });
            }

            // Toast notification function
            function showToast(message, isError = false) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast ${isError ? 'error' : ''}`;
                toast.classList.add('show');

                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }

            // Export tournament data
            function exportData() {
                const tournamentData = {
                    version: '3.0',
                    timestamp: new Date().toISOString(),
                    playerCount: currentPlayerCount,
                    players: {},
                    tournamentStructure: matchConfigs,
                    scores: [],
                };

                // Export player names
                for (let i = 1; i <= currentPlayerCount; i++) {
                    const input = document.getElementById(`player${i}`);
                    tournamentData.players[i] = input ? input.value || `Player ${i}` : `Player ${i}`;
                }

                // Export scores with match structure
                const scoreInputs = document.querySelectorAll('.score-input');
                let scoreIndex = 0;
                matchConfigs.forEach((round, roundIndex) => {
                    round.forEach((match, matchIndex) => {
                        const team1Score = scoreInputs[scoreIndex] ? scoreInputs[scoreIndex].value || '' : '';
                        const team2Score = scoreInputs[scoreIndex + 1] ? scoreInputs[scoreIndex + 1].value || '' : '';
                        
                        tournamentData.scores.push({
                            round: roundIndex + 1,
                            match: matchIndex + 1,
                            team1: match[0],
                            team2: match[1],
                            team1Score: team1Score,
                            team2Score: team2Score
                        });
                        
                        scoreIndex += 2;
                    });
                });

                // Create and download file
                const dataStr = JSON.stringify(tournamentData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);

                const link = document.createElement('a');
                link.href = url;
                link.download = `pickleball-doubles-tournament-${currentPlayerCount}players-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                showToast('Tournament data exported successfully!');
            }

            // Import tournament data
            function importData(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const tournamentData = JSON.parse(e.target.result);

                        // Validate data structure
                        if (!tournamentData.players) {
                            throw new Error('Invalid tournament data format');
                        }

                        // Set player count and regenerate tournament
                        if (tournamentData.playerCount) {
                            document.getElementById('playerCount').value = tournamentData.playerCount;
                            
                            // If we have tournament structure, use it; otherwise generate new one
                            if (tournamentData.tournamentStructure) {
                                currentPlayerCount = tournamentData.playerCount;
                                matchConfigs = tournamentData.tournamentStructure;
                                
                                // Update info text
                                const roundsCount = matchConfigs.length;
                                const matchesPerRound = Math.floor(tournamentData.playerCount / 4);
                                document.getElementById('roundsCount').textContent = roundsCount;
                                document.getElementById('matchesPerRound').textContent = matchesPerRound;

                                generatePlayerInputs();
                                generateTournamentRounds();
                                generateSummarySection();
                            } else {
                                generateTournament();
                            }
                        }

                        // Import player names
                        for (let i = 1; i <= currentPlayerCount; i++) {
                            const input = document.getElementById(`player${i}`);
                            if (input && tournamentData.players[i]) {
                                input.value = tournamentData.players[i];
                            }
                        }

                        // Import scores
                        if (tournamentData.scores && tournamentData.scores.length > 0) {
                            // New format with structured scores
                            if (typeof tournamentData.scores[0] === 'object') {
                                const scoreInputs = document.querySelectorAll('.score-input');
                                let scoreIndex = 0;
                                
                                tournamentData.scores.forEach((scoreData) => {
                                    if (scoreIndex < scoreInputs.length) {
                                        scoreInputs[scoreIndex].value = scoreData.team1Score || '';
                                        scoreInputs[scoreIndex + 1].value = scoreData.team2Score || '';
                                        scoreIndex += 2;
                                    }
                                });
                            } else {
                                // Old format with simple array
                                const scoreInputs = document.querySelectorAll('.score-input');
                                tournamentData.scores.forEach((score, index) => {
                                    if (index < scoreInputs.length && score !== '') {
                                        scoreInputs[index].value = score;
                                    }
                                });
                            }
                        }

                        // Update displays
                        updatePlayerDisplays();
                        updateStats();

                        showToast('Tournament data imported successfully!');
                    } catch (error) {
                        console.error('Import error:', error);
                        showToast('Error importing tournament data. Please check the file format.', true);
                    }
                };

                reader.readAsText(file);
                event.target.value = '';
            }

            // Clear all data
            function clearAllData() {
                if (confirm('Are you sure you want to clear all tournament data? This action cannot be undone.')) {
                    // Clear player names
                    for (let i = 1; i <= currentPlayerCount; i++) {
                        const input = document.getElementById(`player${i}`);
                        if (input) input.value = '';
                    }

                    // Clear scores
                    clearScores();

                    // Update displays
                    updatePlayerDisplays();
                    updateStats();

                    showToast('All tournament data cleared!');
                }
            }

            // Update player display when names are entered
            function updatePlayerDisplays() {
                const players = {};
                for (let i = 1; i <= currentPlayerCount; i++) {
                    const input = document.getElementById(`player${i}`);
                    players[i] = input ? input.value || `Player ${i}` : `Player ${i}`;
                }

                // Update all player displays in matches
                document.querySelectorAll('.player-display').forEach((display) => {
                    const playerNumbers = display.getAttribute('data-players').split(',');
                    const playerNames = playerNumbers.map((num) => players[parseInt(num)]);
                    display.textContent = playerNames.join(' & ');
                });

                // Update summary section player names
                for (let i = 1; i <= currentPlayerCount; i++) {
                    const summaryElement = document.getElementById(`summary-${i}`);
                    if (summaryElement) {
                        const playerNameElement = summaryElement.querySelector('.player-name');
                        if (playerNameElement) {
                            playerNameElement.textContent = players[i];
                        }
                    }
                }

                // Update stats
                updateStats();
            }

            function updateStats() {
                const scoreInputs = document.querySelectorAll('.score-input');
                playerStats = {};

                // Initialize stats for all players
                for (let i = 1; i <= currentPlayerCount; i++) {
                    playerStats[i] = { wins: 0, points: 0, playerId: i };
                }

                // Process each match
                let scoreIndex = 0;
                matchConfigs.forEach((round) => {
                    round.forEach((match) => {
                        const team1Score = parseInt(scoreInputs[scoreIndex].value) || 0;
                        const team2Score = parseInt(scoreInputs[scoreIndex + 1].value) || 0;
                        scoreIndex += 2;

                        // Add points to each player on both teams
                        match[0].forEach((player) => {
                            playerStats[player].points += team1Score;
                        });
                        match[1].forEach((player) => {
                            playerStats[player].points += team2Score;
                        });

                        // Determine winner and add wins to all players on winning team
                        if (team1Score > team2Score) {
                            match[0].forEach((player) => {
                                playerStats[player].wins += 1;
                            });
                        } else if (team2Score > team1Score) {
                            match[1].forEach((player) => {
                                playerStats[player].wins += 1;
                            });
                        }
                    });
                });

                // Sort players by wins (descending), then by points (descending) as tie-breaker
                const sortedPlayers = Object.values(playerStats).sort((a, b) => {
                    if (b.wins !== a.wins) {
                        return b.wins - a.wins;
                    }
                    return b.points - a.points;
                });

                // Update the display with rankings
                for (let i = 0; i < sortedPlayers.length; i++) {
                    const player = sortedPlayers[i];
                    const summaryElement = document.getElementById(`summary-${player.playerId}`);
                    const rankBadge = document.getElementById(`rank-badge-${player.playerId}`);
                    const rankText = document.getElementById(`rank-${player.playerId}`);

                    if (summaryElement) {
                        const winsElement = summaryElement.querySelector('.wins');
                        const pointsElement = summaryElement.querySelector('.points');

                        if (winsElement) {
                            winsElement.textContent = `${player.wins} Wins`;
                        }
                        if (pointsElement) {
                            pointsElement.textContent = `${player.points} Points`;
                        }

                        // Update rank badge
                        if (rankBadge) {
                            rankBadge.textContent = i + 1;

                            // Style rank badges
                            rankBadge.className = 'rank-badge';
                            if (i === 0) {
                                rankBadge.classList.add('first');
                                summaryElement.classList.add('winner');
                                summaryElement.classList.remove('second', 'third');
                            } else if (i === 1) {
                                rankBadge.classList.add('second');
                                summaryElement.classList.add('second');
                                summaryElement.classList.remove('winner', 'third');
                            } else if (i === 2) {
                                rankBadge.classList.add('third');
                                summaryElement.classList.add('third');
                                summaryElement.classList.remove('winner', 'second');
                            } else {
                                summaryElement.classList.remove('winner', 'second', 'third');
                            }
                        }

                        // Update rank text
                        if (rankText) {
                            const place = i + 1;
                            let placeText;
                            if (place === 1) placeText = '1st Place';
                            else if (place === 2) placeText = '2nd Place';
                            else if (place === 3) placeText = '3rd Place';
                            else placeText = `${place}th Place`;

                            rankText.textContent = placeText;
                        }
                    }
                }
            }

            // Initialize tournament on page load
            window.onload = function () {
                generateTournament();
            };
        </script>
    </body>
</html>
